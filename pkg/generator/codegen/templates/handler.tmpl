// Code generated by apikit. DO NOT EDIT.

package {{.PackageName}}

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strconv"
{{- range .Imports }}
	"{{ . }}"
{{- end }}
)

{{- range .Handlers }}

// {{ .WrapperName }} wraps the {{ .Name }} handler with HTTP request parsing and response handling
func {{ .WrapperName }}(handler func(context.Context, {{ .ParamType }}{{ if .HasResponseWriter }}, http.ResponseWriter{{ end }}{{ if .HasRequest }}, *http.Request{{ end }}) ({{ .ReturnType }}, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		var payload {{ .ParamType }}

		// Parse request parameters
		if err := {{ .ParseFuncName }}(w, r, &payload); err != nil {
			apikit.HandleError(w, apikit.BadRequest("failed to parse request").WithCause(err))
			return
		}

		{{- if .HasValidation }}
		// Validate request payload
		if err := validator.StructCtx(r.Context(), &payload); err != nil {
			// Preserve structured validation errors
			if valErr, ok := err.(validator.ValidationError); ok {
				apikit.HandleError(w, apikit.UnprocessableEntity(valErr.Message).WithDetails(valErr.FieldErrors))
			} else {
				apikit.HandleError(w, apikit.UnprocessableEntity("validation failed").WithCause(err))
			}
			return
		}
		{{- end }}

		// Call the handler
		response, err := handler(r.Context(), payload{{ if .HasResponseWriter }}, w{{ end }}{{ if .HasRequest }}, r{{ end }})
		if err != nil {
			apikit.HandleError(w, err)
			return
		}

		// Write response
		apikit.WriteJSON(w, response)
	}
}

// {{ .ParseFuncName }} parses the HTTP request into the payload struct
func {{ .ParseFuncName }}(w http.ResponseWriter, r *http.Request, payload *{{ .ParamType }}) error {
{{- if .HasExtractionCode }}
	// Extract parameters
{{ .ExtractionCode }}
{{- end }}

{{- if or .HasBody .HasRawBody }}
	// Parse JSON body with size limit (10MB) to prevent DoS attacks
	if r.Body != nil {
		defer r.Body.Close()
		const maxBodySize = 10 * 1024 * 1024 // 10MB
		limitedReader := io.LimitReader(r.Body, maxBodySize)
		body, err := io.ReadAll(limitedReader)
		if err != nil {
			return fmt.Errorf("reading body: %w", err)
		}
		{{- if .HasRawBody }}
		// Assign raw bytes to RawBody field
		if len(body) > 0 {
			payload.{{ .RawBodyFieldName }} = body
		}
		{{- end }}
		{{- if .HasBody }}
		// Parse JSON body into payload
		if len(body) > 0 {
			if err := json.Unmarshal(body, payload); err != nil {
				return fmt.Errorf("parsing JSON: %w", err)
			}
		}
		{{- end }}
	}
{{- end }}

	return nil
}
{{- end }}
